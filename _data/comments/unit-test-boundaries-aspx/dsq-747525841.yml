id: dsq-747525841
date: 2008-07-27T05:07:44.0000000-07:00
name: Bryan Call
avatar: https://disqus.com/api/users/avatars/Bryan Call.jpg
message: <p>This is some great advice.  I've been doing TDD for about 5 year now.  Early on I had a lot of tests that crossed boundaries and I paid for it in terms of maintainability and difficulty in implementing TDD.  When you don't cross boundaries it becomes easier to write your tests, teach others to write them and your tests are less fragile.  It will lead to better design as well as better tests.  Mocks are an invaluable tool in accomplishing this.  <br>Regarding some of the comments on stored procedure logic etc, one thing I would add is that while a unit test shouldn't cross boundaries I believe both sides of the boundary should be tested where practical.  So in the case of logic in your database (which I personally avoid) I would consider writing unit tests specifically for your database.  You may isolate them in a seperate assembly to avoid having them run with your other unit tests as they will most likely take longer.<br>Now how do you test code that calls your database.  I personally have all database code go through what I call a DatabaseProvider class.  It has methods like ExecuteNonQuery, ExecuteDataTable etc that allow both dynamic sql or stored procedures to be executed and the results to be returned.  In my unit tests I use a mock version of the DatabaseProvider and test that my business logic code properly executed all the commands against the database that I expected.  I have it set up so I can simluate transactions and test when a transaction is committed or rolled back and whether a given command is executed as part of the transaction or not.  This layer of isolation from the actual database allows me to test that the database is properly called without depending on its existence.  At that point the only question is whether the sql commands I send the database are actually valid.  <br>I handle testing that seperately from testing all the business logic that calls the database.  I tend to use stored procedures most of the time but keep them very simple, without any real logic.  I have a seperate test assembly that I also write using NUnit.  I've written some custom asserts I use in it to test for the existence of the stored procedures my business logic calls.  I test that they take in the parameters I expect so I can catch any problems between what the business layer sends the database and what the database requires.  I do this by querying the informational schema views in sql server so no commands are actually executed in the database.  I've started actually executing select only stored procs to also test they return the columns I expect.  I leave the testing of the sql statements within the stored procedures to other testing techniques.  Because I keep my stored procedures very simple I rarely find problems in them and other testing techniques help me catch them.</p>
