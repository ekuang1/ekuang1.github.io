id: dsq-747525821
date: 2008-07-23T20:56:02.0000000-07:00
name: Rob G
avatar: https://disqus.com/api/users/avatars/Rob G.jpg
message: "<p>Hey Phil, great post! <br>And while I wish I could say I agree with you completely, I do so only in theory - in practice, I have found very different terminologies coming from people in the teams I've worked with - and therein lies the rub: people (in real world teams I've worked on) can't agree on terminology, and I'm sure it's no different with you. You can point to Martin Fowler's work or definitions from eXtreme Central all you like, but not everyone is going to take it to heart. Everyone knows what a PDF or WWW is, and few would disagree on the general use of the term - seems almost as if it needs to be wrapped in an ISO standard before people actually believe that's what it truly is.<br>For example - \"unit test\" to you (in basic terms) means testing a piece of code without crossing any boundaries. Others call it testing a piece of code that performs a single unit of work. Trying to argue with a guy that says: \"I'm testing if the columns still exists in the DB Table! That way, if someone stoooopidly decides to delete or rename a column, Cruise Control will pick it up and show a broken build.\".<br>Now take note of a few things here:<br>1. He knows what Cruise Control is, and therefore what CI is all about.<br>2. The test code written for this example is extremely short.<br>3. He insists that the test is valid because it performs a single unit of work.<br>But according to your definition, he's broken the rule of crossing boundaries - and I tend to agree. You tell him that it's actually an integration test, but he says NOOOOO, it's only testing one unit of work - therefore, by his definition is still a unit test. Oh, and he also says it's blazin' fast too :-)<br>This really just boiled down to a simple case of semantics really, because in the wide world out there, not everyone calls a spade a spade - I think you guys call it a shovel :-)<br>Apologies for the long post, but there's one more question I'd like to ask. At which point do you actually test your LINQ to SQL queries - for real I mean - not mocking up the DataContext because you want it snappy. Afterall, what you really want to know is if the database can comply with your requests - no? I'm only talking here about a simple unit (don't shoot) test - the MemberRepository would like to add a Member to a Role - nothing fancy, just one class hitting the DB and getting a positive Assert out of it. That call hits the mock otherwise and gives me no real value because I can just tell the mock to \"return true\".<br>Is there not some middle ground where we can still call these \"unit tests\", but put it into a different testing project - I dunno,  call it: \"slower unit tests\" or something?<br>Looking for some diretion here...<br>Cheers,<br>Rob</p>"
