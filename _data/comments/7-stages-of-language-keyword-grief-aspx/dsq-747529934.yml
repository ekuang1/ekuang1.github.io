id: dsq-747529934
date: 2009-09-02T08:12:00.0000000-07:00
name: Haacked
avatar: https://github.com/haacked.png?size=120
message: <p>@Bryan says it much better than I did.<br></p><blockquote><br>I wonder about the line of reasoning that says "static is static and dynamic is dynamic and never the twain shall meet". Developing well-implemented features that enable core scenarios is what language writers are paid to do. They are not paid to maintain anachronistic lines between obviously converging paradigms.</blockquote><p><br>@Mark I don't agree that using a dynamic language suddenly means you throw good design out the door. Good design is still a key element no matter which type of language you use.<br>Design Patterns, for example, are common patterns of solutions to common problems. What's interesting is some of those problems are a result of static languages themselves. In many cases, dynamic languages don't need the same design patterns because there's no problem in the first place.<br>I think there are a whole new set of design patterns that need to be hashed out with dynamic languages. I think that's the beauty of the dynamic keyword in C# though. In the rare cases when I'm writing a bunch of static code following some pattern that's unnecessary in a dynamic language, I can simply use the dynamic feature and simplify the code.<br>@Rob ok, right tool for the right job. Show me an example of calling into Ruby from C#. Lessee. You have to create a DLR Host. Now you have to create a Ruby context within that host. Now find the source you want to execute and load it into the host. And so on.<br>I think writing Ruby plugins on-top of an existing application where the application is <em>already a host for Ruby</em> is great! I've shown many examples of this on my blog.<br>But in cases where your app isn't already a Ruby host, and you simply want to call into something dynamically, it's a pain to switch to Ruby just to do a small thing dynamically.</p>
