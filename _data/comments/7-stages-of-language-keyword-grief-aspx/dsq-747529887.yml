id: dsq-747529887
date: 2009-08-31T13:25:00.0000000-07:00
name: Jason Olson
avatar: https://disqus.com/api/users/avatars/Jason Olson.jpg
message: "<p>I would disagree that the dynamic keyword simply \"makes reflection easier.\" In my mind, there are two simple reasons why the dynamic keyword exists: 1) Dynamic Language interop (calling out to IronPython, IronRuby, [insert_some_other_dlr_lang_here]) and 2) COM Interop (perhaps better read as \"Office Interop\"). <br>When it comes to interop'ing with COM, it's a very powerful feature. When it comes to interop'ing with dynamic languages, it's also a very powerful feature. Outside of that? Not so much. <br>Will it be abused? Absolutely it will! But that's true of almost every technology \"improvement\"/\"feature\". A feature isn't evil by itself simply because it can be used for evil. Are computers evil because terrorists can use them to coordinate their actions? That's a bit of a tangent though that is better suited for discussion over beers :). <br>What's my personal take on this feature? While I see its usefulness in places, my reaction is honestly one of fear. Not fear of the dynamic language itself, that's not the problem. It's the fear that C# as a language is becoming more of a \"jack of all trades, master of none\" with each successive release. There is something to be said for a simple, elegant language that focuses on a specific scenario (or category of scenarios) and does them exceedingly well. <br>Compare .NET land with the JVM space. Adoption of new languages built on the JVM is an increasingly popular paradigm on \"the other side of the forest\". Look at the growing popularity of Scala, Groovy, Clojure, etc. The most powerful languages are powerful because they minimize the amount of cognitive dissonance that is present when people learn to use the language. In other words, their concept count is low. Smalltalk and LISP are excellent languages that exhibit this aspect. Unfortunately, they didn't exactly \"win\" in the language space (though that can be explained by many other factors outside of language design). <br>So, long story short, I fear that C# is introducing more and more concepts that a \"new\" C# developer (or even existing C# developers) need to know in order to be efficient. What if it continues to be an excellent general purpose language that is truly \"general\" purpose and doesn't particularly excel at anything?</p>"
