id: dsq-747529929
date: 2009-09-02T03:02:00.0000000-07:00
name: David Nelson
avatar: https://disqus.com/api/users/avatars/David Nelson.jpg
message: "<p>I seem to be in perfect agreement with Rob, which has me very worried :)<br>\"...you kind of relegated everyone's negative comments to a kid who's cat died.\"<br>Indeed, it is bad form and frankly somewhat insulting to state that everyone who disagrees with you about the utility and value of a feature is automatically guilty of FUD.<br>\"You flex a language and its strengths, or you don't.\"<br>This is the key point to me. Sure dynamic has potentially huge value in very small areas. And yes, bad programmers will write bad code no matter what language features are available. These are the edge cases, and they are not what concerns me.<br>What concerns me, is the middle ground where *framework designers* will start to see dynamic as a way to get around all of the pesky things that the (inherently strongly typed) .NET platform currently forces you to do. Your interfaces seem to be getting too large and unwieldy for consumers to implement correctly? Don't bother refactoring, just use dynamic instead! Framework consumers now have a choice: use dynamic in their own code where it is clearly not wanted, or ditch the framework altogether, which defeats one of the primary purposes of using the .NET Framework in the first place (framework support).<br>I simply don't understand why the C# design team chose to set up developers and the platform for failure this way. If nothing else, they could have done what they did for unsafe code and forced the use of a dynamic compiler switch. This would be a strong deterrent against overuse of the feature, while still allowing those who need it to use it without much extra hassle. Yet they didn't even do that.<br>@Bertrand,<br>The great thing about telling someone that they are in denial is that they can't deny it. That doesn't make it true.</p>"
