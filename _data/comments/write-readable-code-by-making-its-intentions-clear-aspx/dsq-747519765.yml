id: dsq-747519765
date: 2008-07-08T08:58:23.0000000-07:00
name: Jolyon Smith
avatar: https://disqus.com/api/users/avatars/jolyonsmith.jpg
message: "<p>There's a problem with your analysis of the first example (or perhaps with the simplification of it, but since you have since (LONG since) updated those, that shouldn't be the case any more - but either way...)<br>public bool TrySomething(object something, ref int y)<br>{<br>  try<br>  {<br>    y = resultOfCalculation(something);<br>  }<br>  catch(SomeException)<br>  {<br>    return false;<br>  }<br>  return true;<br>}<br>Is not guaranteed to set the y param.  If, as would appear to be not only possible but expected, an exception occurs in resultOfCalculation, then y will not be set - if the caller has not initialised it then the value of y is potentially undefined.<br>So, as implemented (to expect and silently handle all exceptions) the y param absolutely should be required to be initialised before calling this routine.<br><br>2nd example: Instead of having to pause and figure out what TRUE/FALSE means in your alternate approach the reader now has to wonder what:<br>  PostStatus.Published<br>  CommentStatus.CommentsDisabled<br>are.  Are these functions or properties of the two Status objects?   Where does one find these objects?  What do these properties/functions yield?<br>Oh by all means, looking at the parameter declarations will help figure out that they are enum values?  But, those same declarations should help answer the \"What does TRUE/FALSE mean?\" question too.  If we're to be forced to use the param declarations to interpret the param values, shouldn't the param values be as simple as possible to avoid the possibility of further confusion?<br>If I were to do anything in this case it might be to illuminate the param name as a comment:<br>   BlogPost p = CreatePost(post, (*Published*)true,<br>                                 (*Comments*)false);<br>Just as revealing, arguably clearer and certainly less verbose. <br>Possibly dangerous too of course.  What if the params were reversed at some future point for some bizarre reason?<br>So where there are multiple such params, I'd be tempted to collapse them all into a \"flags\" param, accepting an enum set. Rigidly safe and furthermore easily extendable without impacting on existing code.<br>The only thing is - I use Delphi, in which set types are very simple, but aiui, C# is somewhat lacking in this fundamental area.<br>So perhaps the real lesson is, if you want to produce readable code, use a language that intrinsically promotes it without taking away any of the power you need, instead of one that you have to work hard at to produce barely readable code for even the simplest things.<br>;)</p>"
