id: dsq-1118218970
replyToId: dsq-1118050482
date: 2013-11-11T08:40:22.0000000-08:00
name: Alex Burke
avatar: https://disqus.com/api/users/avatars/alex_burke.jpg
message: <p>Actually I've thought about this alot and actually I think I responded in haste. Conditional branching is costly if the branching was unnecessary in the first place. I don't see how you can get around it though (JZ,JNZ,JAE,JBE,JNLI all have a logical comparison component) and there are far more costly operations the x86 can perform depending largely on the available instructons sets/opcodes.</p><p>The trouble is it all depends on what language, platform you are on as to what is the best solution and you make a point about the orig C function strlen(), however where i widely disagree is the fact that in its original intent, the programmer was supposed to KNOW it wasnt a memory safe operation. All you have as an improvement is to insert into the function a length parameter ergo a conditional branch (a few actually jmp if zero, jmp if larger than you max container, JLE etc) which depending on what you are TRYING to do affects how optimised you need it to be and adds cycles to the process time. I like the old implementation not because it is unforgiving but i feel it does lead to better design choices - precheck/assert before you use it etc or fixed length buffers that dont need the extra checks - every other variant is doing it for you which is fine if you don't care about the overhead. To not inform people there is a distinction is wrong.</p><p>The caveat to that is the more platforms you use, languages etc you form an idea/palette of choices about which library platform functions are typesafe/memsafe/not buggy or even vendor safe and also best fit for the problem you are given and the limitations of your brief etc.</p><p>Nobody said you HAVE to write everything yourself as that is inefficient, however I'd rather teach there is a rule that has exceptions, that inform design choices and implementations, rather than just brush over it with you don't need to know how it works because microsoft wrote all .NETs functions perfectly. (Or suns java functions or dammit apples NS functions. Jesus some win32 functions actually have handles for things that weren't ever implemented not to mention undocumented opcodes on chips ala the 6502)</p>
