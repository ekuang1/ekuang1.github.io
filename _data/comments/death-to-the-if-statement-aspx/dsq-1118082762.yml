id: dsq-1118082762
date: 2013-11-11T06:57:01.0000000-08:00
name: H.M. MÃ¼ller
avatar: https://disqus.com/api/users/avatars/hmmller.jpg
message: "<p>Being a mathematics aficionado, I also like these \"elegant\", \"decision-less\" solutions.</p><p>HOWEVER, I have found out that when thinking about such algorithms, almost always we (all stakeholders in the code: analysts, testers, and also these lowly programmers) argue by cases: \"Let's assume the list is longer, then ...; but if it is shorter, then ...\".</p><p>And all the (unit and other) tests done will also do this.</p><p>So my experience is that you have gained nothing - nothing at all; and the risk is HIGHER that maintenance introduces errors because each change \"changes all cases together\".</p><p>Yes, if someone writes code where ONLY the cases that behave VERY SIMILARLY are grouped together with such ideas, THEN the code really becomes much better to maintain (I hesitate to write \"easier to maintain\" ...).</p><p>But if the grouping becomes like tricky like in the original example (where the max is just another \"case-distinguishing operator\", i.e., something, which exactly the same amount of \"think time\" as an if), then the maintainers will curse you more ....</p><p>----------</p><p>A special case: In PASCAL (my first language) and all later languages, you can write</p><p>     boolVar := a &gt; b;</p><p>For a long time I and many other \"advanced\" guys laughed at the people who wrote</p><p>IF a &gt; b <br>     THEN boolVar := TRUE <br>     ELSE boolVar := FALSE;</p><p>However, after having worked (and instructed) larger teams, I found that the latter allows you do add comments \"at the right place\":</p><p>IF a &gt; b <br>  (* This is the usual case when the user does this and that ... *)<br>     THEN boolVar := TRUE <br>  (* Only when that funny things happens, we arrive at this place; this has a few consequences downstream, namely ... *)<br>    ELSE boolVar := FALSE;</p><p>This structure is lost in the \"elegant\", IF-less formulation ...</p><p>=======</p><p>Nevertheless, refactorings like \"replace cases with polymorphism\" and also \"replace cases with encompassing algorithm\" (as in the article) are valuable tools of the trade ...</p><p>H.M.M.</p>"
