id: dsq-1118629405
date: 2013-11-11T13:44:40.0000000-08:00
name: Andy Wilkinson
avatar: https://disqus.com/api/users/avatars/Andy Wilkinson.jpg
message: <p>Before I start I will openly admit that I am being picky with terminology here, but I'm not sure the comparison with "functional" programming is really correct. I would argue that we are really talking here about the difference between "declarative" and "imperative" approaches instead.</p><p>In my experience functional programming tends to favour pattern matching which ultimately is a super powerful 'if' statement. If I was to rewrite the padded take in C# in a functional style then I'd propose something like,</p><p>public static ImmutableLinkedList&lt;t&gt; PaddedTake&lt;t&gt;(<br>  this ImmutableLinkedList&lt;t&gt; source, int count)<br>{<br>    if (count == 0)<br>        return ImmutableLinkedList&lt;t&gt;.Empty;<br>    else if (source.IsEmpty)<br>        return PaddedTake&lt;t&gt;(source, count-1).Add(default(T));<br>    else<br>        return source.HeadList.Add(PaddedTake&lt;t&gt;(source.Tail, count-1));<br>}</p><p>Note that this uses a (hypothetical) linked list implementation as often observed in functional programming and makes heavy use of recursion. In reality C# quickly heads towards stack overflow exceptions with this (which is why F# correctly implements tail-recursion(.</p><p>This doesn't mean that the "declarative" approach discussed above is less powerful, in fact I'm a big fan of moving away from imperative logic and I would suggest the implementation I've given above isn't the easiest to understand... (I did say I was being picky didn't I?!)</p>
