id: dsq-747525536
date: 2008-06-19T07:21:12.0000000-07:00
name: Damon Carr
avatar: https://disqus.com/api/users/avatars/Damon Carr.jpg
message: <p><br>I see this a lot lately in C# 3.0 implementations and it perhaps I am 'old-school' but if I saw this in the wild more (nothing I say here is unique) I might not feel compelled. <br>As 'service providing' code (especially decorator style adornments) is migrated away from any pure contractual representation of our expectations of the partitipants in our complex system interactions (this assumes the code spans projects and has a central architectural focus).<br>In my opinion I treat this pattern you have described (as well as the more common 'single method/property interface' marker which is then extended at will using extension methods as 'design debt'.<br>All things in moderation I suppose.. What do you think? I get concerned now as I am seeing so much of a swing away from 'contract driven' services and using interfaces as concrete immutable items for our hinges. Sure it's a pain but I don't think managing free-form namespace imports for extension methods is workable in large scale software. <br>I prefer to preach a fairly conservative line which I know you also are well aware of:<br>1) A 'service' which is aggregated by it's consumer is typically preferred to inheritance (how many times have you heard that one - grin)...<br>2) To define an unambiguous definition for interoperability and versioning, a service that is non-trivial has some 'pure abstract' contract, and due to .NET that means an Interface more then not.<br>3) As mentioned, leveraging interesting optimizations when resolving service dependencies for injection rather then matching code to run-time state via typical prop/constructor injection.<br>Again, nothing you don't know and in the Agile 'design debt' sense as long as this style is managed (I do it all the time) it's quite productive.<br>I've also seen an alarming number of others dramatically violate 'single responsibility' design in passing Linq expressions that are lazilly resolved between tiers. For example, in the MVP pattern code that constructs the elements of a to be compiled expression tree partially in the view, then in the presenter, and even adding a dash of data in the domain model to be invoked.. UGH.. It's not as bad a literal dependencies I suppose but it's still white box..<br>Is there a decent contractual obligation we can expose using this pattern that would satisfy what I am getting at?<br>Kind Regards and well done,<br>Damon Wilder Carr<br><a href="http://damon.agilefactor.com/" rel="nofollow noopener" title="http://damon.agilefactor.com/">http://damon.agilefactor.com/</a></p>
