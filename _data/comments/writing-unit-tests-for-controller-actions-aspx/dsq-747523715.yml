id: dsq-747523715
date: 2007-12-25T12:35:40.0000000-08:00
name: Alexey
avatar: https://disqus.com/api/users/avatars/Alexey.jpg
message: '<p>Hi Phil,<br>Thank you for the answer – can’t wait to play with release version :)<br>There is another suggestion I’ve got as a result of my experiments.<br>IMHO, using mocked IViewFactory (like it’s done in your samples) is not very convenient,<br>though it’s absolutely fine for me to use mocked IHttpContext (as it’s only a single line of code). <br>The problem with mocked view is that complexity of mocking code increases as you need to get <br>more complex behavior from view. As a result, you get barely readable code (the code which <br>creates mocked objects).<br>For the views, I prefer using a simple fake class which implements 3 interfaces – everything you <br>need to mock view behavior:<br><code><br>    internal class MockView : IViewFactory, IView, IViewDataContainer {<br>        private object viewData = null;<br>        private string viewName = null;<br>        #region IViewFactory Members<br>        public IView CreateView(ControllerContext controllerContext, string viewName, string masterName, object viewData) {<br>            this.viewName = viewName;<br>            this.viewData = viewData;<br>            return this;<br>        }<br>        #endregion<br>        #region IView Members<br>        public void RenderView(ViewContext viewContext) {<br>            return;<br>        }<br>        #endregion<br>        #region IViewDataContainer Members<br>        public object ViewData {<br>            get {<br>                return viewData;<br>            }<br>        }<br>        #endregion<br>        public object ViewName {<br>            get {<br>                return viewName;<br>            }<br>        }<br>    }<br></code><br>In this case, tests become more readable e.g.<br><code><br>        [TestMethod]<br>        public void ProductCategoriesUsesCorrectView() {<br>            ProductsController controller = new ProductsController();<br>            MockView mockView = new MockView();<br>            MockRepository mocks = MvcHelpers.InitializeControllerWithMockedData(controller, mockView);<br>            controller.Categories();<br>            mocks.VerifyAll();<br>            Assert.AreEqual("Categories", mockView.ViewName);<br>        }<br></code><br>Note that here, in case of using incorrect view in controller code, the test would fail with more readable error message (because AreEqual call fails) whereas in original code (with mocks) that would be System.NullReferenceException which is not so obvious.<br>Also, with fake class, you can easily check whether data passed to view correct or not:<br><code><br>        [TestMethod]<br>        public void ProductCategoriesHasData() {<br>            ProductsController controller = new ProductsController();<br>            MockView mockView = new MockView();<br>            MockRepository mocks = MvcHelpers.InitializeControllerWithMockedData(controller, mockView);<br>            controller.Categories();<br>            mocks.VerifyAll();<br>            Assert.IsInstanceOfType(mockView.ViewData, typeof(List&lt;ProductCategory&gt;));<br>            List&lt;ProductCategory&gt; categories = mockView.ViewData as List&lt;ProductCategory&gt;;<br>            Assert.AreNotEqual(0, categories.Count);<br>        }<br></code><br>I tried to implement that behavior using mocks, but, as I said at the beginning, I got almost non-readable code which dealt with creating of mocked objects.<br>Again, everything here is my IMHO.<br>And, of course, thanks a lot for the job your team is doing in ASP.NET MVC – it’s really cool framework and I like it!</p>'
