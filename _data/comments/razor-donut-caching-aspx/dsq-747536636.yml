id: dsq-747536636
date: 2012-08-22T17:39:43.0000000-07:00
name: Aaron
avatar: https://disqus.com/api/users/avatars/Aaron.jpg
message: <p>Tthe challenge with my design proposal implies that the cached parent page might be passing Model parameters to the child ActionMethod.  So whenever a cache is generated for the parent page, in addition to preserving information about the @Html.Action call, you would also need to evaluate all parameters to literals.  This will avoid having to also cache the @Model or any viewbag values being passed to the Action.  So @Html.Action("Blah", new { id = @Model.Id }) becomes @Html.Action("Blah", new { id = 5 }) in the cached parent page.  Consider how this would solve the existing problem of displaying the username of a user in the Layout page but caching the FAQ.  User A visits the FAQ question ID=1,  the FAQ is configured to vary by param id.  A cache for parent page FAQ is generated for id=1.  The call to @Html.Action("QuestionText", new { id = Model.Id }) becomes @Html.Action("QuestionText", new { id = 1 }).  The QuestionText child action also has OutputCache configured for varyby param, which is coincidental, because when I wrote that action, I know that the result of the action varies based on what question is being retrieved.  I don't really think about the parent page when deciding the caching config of child actions.  I do have to think about the caching config of parent pages though, because if I configured the FAQ page only on duration, and not ID, then the first request for ID=1 will be retrieved for ID=2, and the literal "id=1" will be passed to the action method instead of 2.  No on the other hand, the @Html.Action("WelcomeUserName") is completely independent of its parent view, because it takes no parameters, and thus even if the parent view is cached, it will be called and eveluated based on its own output cache, which would probably not be cached or have a VaryByCustom based on retrieving the current logged in user.</p>
