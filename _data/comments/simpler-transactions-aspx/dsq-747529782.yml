id: dsq-747529782
date: 2009-08-20T01:54:00.0000000-07:00
name: David Meyer
avatar: https://disqus.com/api/users/avatars/David Meyer.jpg
message: <p>I've used this too, but with a custom system I designed very similar to System.Transactions to implement transactionality when using a specific third-party library.<br>I agree that to save one line of code may not be worth other considerations.  But I have also forgotten to commit transactions, which is a bigger problem.  Currently, if you forget to do this, it will not show up as a compile-time or run-time error.  It will only have the effect of never commiting that transaction.  But even assuming that you always write a functional test to verify the code, wouldn't it be better to catch it sooner?  Say, at compile-time?  Especially since some systems can have functional tests that take a long time to execute.<br>Basically, the best solution would be to enforce in the language that before execution control leaves the block, the transaction has to be explicitly either committed or rolled back.  This could easily be done in your solution by using Func&lt;TransactionResult&gt; instead of Action for the delegate (where TransactionResult is just an enumeration, could be called soemthing else), which would require the delegate to return whether or not to commit or rollback the transaction before it completes.<br>Or the problem could be solved even simpler by incorporating the fact that it will be committed into the wording of the function.</p>
