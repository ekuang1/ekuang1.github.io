id: dsq-747529790
date: 2009-08-20T17:02:00.0000000-07:00
name: andyclap
avatar: https://disqus.com/api/users/avatars/andyclap.jpg
message: <p>I've been using this for a while, not for compactness or to guard against forgetting to complete, but for separation of concerns. <br>I don't want to know how to run a transaction, all I want to know is that a bit of work should be atomic, viz (c#2):<br>public void DoStuffAndOtherStuffTogether()<br>{<br>  atomicCoordinator.Do(delegate<br>    { <br>      stuff(); <br>      otherstuff();<br>    });<br>}<br>Stems from adapting a project using fugly dbConnection transactions to using TransactionScope. And it helped when testing as I can set up a mock to ensure a bit of work was atomic rather than trying to fail a bit of the transaction and testing it all rolled back.<br>@sean - sprocs vs app code is a whole different debate!<br>@vito - you could use this way of doing things too:<br>MyStuff GetStuff()<br>{<br>  return uncommittedOptimisationIsFineForThis.FetchOf&lt;MyStuff&gt;(delegate<br>  {<br>     return GetMyStuff();<br>  });<br>}<br>Means that if you need to change technologies, the thing that knows how to apply uncomitted optimisations via a transaction scope can decide whether to use it or not (or use a different technique), rather than your code.<br>The messier problem as zvolkov mentioned above is c#'s closures, you have to assume the delegate is going to be called and forgotten, and turn off the warning, hey ho.</p>
