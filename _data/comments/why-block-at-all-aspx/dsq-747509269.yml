id: dsq-747509269
date: 2004-08-08T18:17:00.0000000-07:00
name: Ian Griffiths
avatar: https://disqus.com/api/users/avatars/Ian Griffiths.jpg
message: "<p>One minor niggle with this code...<br><br><br><br>Although the example is correct as it stands, it doesn't mention an important issue: the Socket class is not thread-safe. This means that if you do use the async operations (and by the way, I'm completely with you here - I'm a big fan of the async operations) you need to take steps to synchronize access to the socket.<br><br><br><br>As it stands there's nothing wrong with this example as far as I can see. But what if you also have an asynchronous read operation outstanding? Can you guarantee that a read and a send won't complete simultaneously, and that you'll be trying to access the socket from both completion handlers simultaneously.<br><br><br><br>So in practice, you tend to want to use some kind of locking to guarantee that your socket is only being used from one thread at a time, once you start using async socket IO.<br><br><br><br>(Also, you left out one of the clever parts of IO completion ports - the scheduler tracks which threads are associated with work from an IO port, and tries to make sure that you have exactly as many running as you have CPUs.  If one of the threads handling work from an IO completion port blocks, the OS will release another work item from the completion port. Conversely, if loads of IO operations complete simultaneously, it only lets them out of the completion port as fast as your system can handle them, and no faster - this avoids swamping the scheduler under high load.)</p>"
