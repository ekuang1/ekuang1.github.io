id: dsq-747536400
date: 2011-12-18T20:54:50.0000000-08:00
name: haacked
avatar: https://github.com/haacked.png?size=120
message: <p>@Chris the documentation is not incorrect. You're right, if the first time <code>Stop</code> is called, I could return immediately and let <code>Stop</code> continue to do its work. But now I have to deal with the second time <code>Stop</code> is called which does require the method to call <code>UnregisterObject</code> before it's done.<br>My initial implementation is intended to keep it simple. In effect, I implemented <code>Stop</code> as if it's being called the second time rather than handling these two cases.<br>A more complex implementation would have the first call to <code>Stop</code> signal the work that it needs to wrap up, while the second call to <code>Stop</code> wraps it up immediately. Of course this assumes that the nature of the work being done is even amenable to that sort of interaction. :)<br>I might look into that later, but for now, given the nature of the work I do in the background, this felt sufficient. <br>The part I'm a little unclear on, now that you mention it, is whether the application will try and wait at all for all objects to be unregistered unless you block on one of the <code>Stop</code> calls. If it tried to, that would allow you to simply go asynchronous in both calls of <code>Stop</code> and hope for the best. But as I understand it, this is not the case. I'll double check. :)<br></p>
