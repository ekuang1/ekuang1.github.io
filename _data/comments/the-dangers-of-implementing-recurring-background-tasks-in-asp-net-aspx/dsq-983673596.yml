id: dsq-983673596
date: 2013-08-01T00:02:34.0000000-07:00
name: Simon
avatar: https://disqus.com/api/users/avatars/Simon.jpg
message: <p>I ended up using a different approach (which I'm sure has just as many problems) - A windows Service that loads the assemblies of the website into an AppDomain. It uses reflection to look for classes which implement ITask and executes them when scheduled (as defined by attributes).</p><p>The good news is that this allows me to control the lifecycle, have my own Stop(Force) mechanism, etc.</p><p>I detect when a deploy/update occurs to the site (via a WCF call) and start shutting down the old tasks. When I'm done, I kill the old AppDomain and load new task definitions into a new one.</p><p>This works very smoothly in most circumstances. The only problem is if a publish has to perform database updates, I need some logic in the website to co-ordinate with the service (via WCF) so that it doesn't attempt to pull the rug out from beneath it and either waits for the jobs to complete (with that webserver being unavailable while we wait) or by telling the service to abort running jobs after a short shutdown time so updates can be applied rapidly.</p><p>I don't see this as any worse than any other solution (ie it's a process issue, not an implementation one).</p><p>Of course, this does require that the service can see the assemblies of the website...</p>
