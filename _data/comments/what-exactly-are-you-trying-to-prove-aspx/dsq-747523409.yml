id: dsq-747523409
date: 2007-11-17T00:58:44.0000000-08:00
name: John Stoker
avatar: https://disqus.com/api/users/avatars/John Stoker.jpg
message: <p>You missed the point. I can easily make a program to pass every fixed test you can possibly write -- even write code that will create the program based upon the tests -- and, except in trivial apps, it will not resemble the functionality it should except at the specific points tested. Tests cannot describe general behaviour of beyond the most trivial finite cases. You write 10000 unit tests and I write a lookup table with those 10000 input sets in it that trivially returns correct results for those cases more easily than read your mind for all the cases in the whole continuum that you did not test or specify the behaviour for. Even a woefully incomplete specification is light years ahead of the inherent incompleteness of tests.</p><p><br></p><p>The int function example is completely bogus. You make assumptions about the implementation, which are likely to become false if reimplemented. There is no contract at all for the actual desired behaviour.</p><p><br></p><p>This sort of idea of unit testing is programming backwards -- reminds me of the movie Amadeus, where Mozart says they are in a new place where people fart backwards -- but incomplete. While there is merit and purpose for testing, it can never serve the primary role some people say it should, which is bass-ackwards to programming. They are equivalent to the required design specification only in a world of make believe.</p><p><br></p><p>You write one set of tests focussed on how one implementation was made, and you have no guarantees whatsoever when it is reimplemented, because you only have those points you chose to test based upon assumptions about the original implementation.</p><p><br></p><p>Assertions, like proving things about the behaviour, will also catch a far wider set of problems than fixed tests, because they can specify the behavior across a complete continuum.</p><p><br></p><p>Tests are spot checks, nothing more. Spot checks are good tripwires to catch certain types of breakage in certain types of environments. They are a very poor substitute for design, type systems, assertions, memory management, and many other things that all boil down to guaranteeing/proving things about an implementation.</p><p><br></p><p>This is the horror you get when you promote testers to be programmers. Give me a programmer any day who can design. Making complex things simple is the hardest thing from a design perspective, although plenty will try to foist off simplistic designs as simple when they are not. Design and mathematical reasoning about program behaviour is worth the effort.. With a good design, I can trivially fix any problems to conform to the design. Without a competent design, there is no fixing the behaviour however many tests you may write.</p><p><br></p><p>Without good assertions, you are unlikely to discover that your test failed anyway, let alone catch cases that arise that you didn't test for, etc.</p><p><br></p><p>Please write me the unit test for computing quadratic formula to double precision without assuming an implementation. If you assumed the implementation, then you may as well have written the solution correctly to begin with.</p><p><br></p><p>A test is good as a sanity check. That is all. If you don't think you need anything more to produce quality code, fine, but don't work for me on any project.</p><p><br></p>
