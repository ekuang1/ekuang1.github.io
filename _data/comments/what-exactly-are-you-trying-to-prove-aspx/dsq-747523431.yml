id: dsq-747523431
date: 2007-11-19T22:56:57.0000000-08:00
name: Haacked
avatar: https://github.com/haacked.png?size=120
message: <p>@Frans - Interesting. I think part of our disagreement lies in the fact that the type of software you write is not the necessarily the same as the software many (if not most) developers write.<br>For example, when I was a consultant writing large scale business apps, the code we wrote was not very "algorithmic". Certainly pulling data out of a database, going through some manipulations of that data, and then presenting the data is an "algorithm" in the strictest sense of the word (well-defined instructions for completing a task), but the "algorithm" is custom to every situation and not something you can look up in a book.<br>Most algorithms we used were already "proven" and encapsulated in re-usable components (often 3rd party).<br>So I never had to prove an "entity management system". We used LLBLGen Pro on that project.<br>I'd say the typical large software project rarely writes heavily algorithmic code (as a percentage of entire code base). Much of the code pulls these components together and is focused on UI interactions.<br>Did you prove your UI interactions within the GUI tools for LLBLGen Pro?<br>The other thing is, proving components of your code is not a proof for the whole system. Because then you have to go one step up and prove the interactions of those components and so on.<br>In any case, perhaps our disagreement also lies in a misunderstanding. When you said a developer's *main* concern is writing provably correct code, I thought you meant that I, as a developer, should focus on writing code that could be proved by a formal proof. As in, you could right now present me a proof (perhaps automated) that LLBLGEN Pro is correct code, from the UI down to the nitty gritty. Certainly such proofs are possible in small programs written in LISP, but it seemed to me unreasonable (today).<br>As a developer, I always focus on writing correct code and thinking through the steps of what I write. I can walk you through the code and tell you why it will work. In that regards, I can "prove" my code is correct to a reasonable degree (as a human, my proof might end up being suspect).<br>Personally, I think TDD is a great <em>process</em> for doing that. It's a mental aid for thinking through the design of the code.<br>I still don't think provably correct code nor testability is our main concern.<br>I think Reg Braithwraite <a href="http://weblog.raganwald.com/2007/11/best-question-asked-this-week-what.html" rel="nofollow noopener" title="Best question asked this week">said it well</a>.<br></p><blockquote>I am not saying that strong typing or provability, iterative development or BDD, or anything else is necessarily better or worse in this respect. I am just pointing out that the surface, buzzwords for these things—fewer bugs, provability, test coverage, separation of concerns—are not the goal, they are ways and means of achieving the goal, which is the discovery of the true requirements and the delivery of working software which meets the true requirements over the project’s complete span.</blockquote>
