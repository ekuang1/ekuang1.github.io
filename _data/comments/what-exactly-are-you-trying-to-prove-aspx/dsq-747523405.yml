id: dsq-747523405
date: 2007-11-16T17:54:42.0000000-08:00
name: John Stoker
avatar: https://disqus.com/api/users/avatars/John Stoker.jpg
message: <p>Proving correctness is one of a number of techniques that can be brought to bear. Like testing, it can still be useful even if it is incomplete. But unlike testing, it deals with infinite numbers of cases.</p><p><br></p><p>Unit testing advocates often take testing as a religion and a substitute for adequate and ongoing design, to the extent that they cannot accept that techniques that take into account an infinite number of cases are inherently more complete than techniques that only cover a finite number of cases.</p><p><br></p><p>Every argument I read above about how hard proving correctness supposedly is applies doubly for unit testing, and those who claim that testing is trivial must be doing trivial testing that is useless in all but the most trivial apps.</p><p><br></p><p>The argument of redesigning so you can test better also applies to proving correctness, but, once again, it deals with infinite numbers of cases instead of finite numbers of cases.</p><p><br></p><p>Another technique frequently rejected by testing zealots that, unlike testing, deals with infinite possible numbers of cases is assertions, and the list goes on.</p><p><br></p><p>Testing has its place, but it is not a legitimate replacement for good ongoing design, assertions, and other techniques that prove (even if incompletely, not as incompletely as testing) that portions of the application are correct.</p><p><br></p><p>For the ueberdweebs from extreme programming who claim that designing by test is the right way -- if it passes all the tests it works by definition -- I will write a simple implementation generator that examines the test and derives the implementation from that, covering exactly and only the finite inputs of the test, and claim that this is inherently the simplest most-easily-refactorable and maintainable implementation.</p>
