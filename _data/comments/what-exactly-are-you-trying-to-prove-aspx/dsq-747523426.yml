id: dsq-747523426
date: 2007-11-19T01:26:07.0000000-08:00
name: Brandon Moore
avatar: https://disqus.com/api/users/avatars/Brandon Moore.jpg
message: <p>Sure, specs are fuzzy and change. How do you decide what tests to write? Once you know what you are testing for, you can consider trying to prove it instead. <br>Then it should be just a simple engineering tradeoff - how much confidence can you get for various work with either approach for various properties. Checking that sort always returns a list when given a list is almost certainly best proved (using a type system). Can you really beat a type annotation with any test suite? Checking that it returns an ordered list? Probably easier to test. (hopefully you have something like QuickCheck).<br>Your argument that proving things about programming is really weird. You give an anecdote where you learn it's hard to give closed form solutions to partial differential equations, then decline to go on to learn the mathematical techniques that you say people actually use in practice to establish useful properties about the behavior of partial differential equations (e.g, the value at time t is within e of the value computed by this algorithm). How does this have anything to do with proving programs? In good cases, proving a program works isn't much harder than writing comments that explain how it works. In bad cases, don't prove it!<br>A proof is just a formal explanation of why the code works. The difference comes down to weak tools, or fuzziness in your explanation. So subtract the tools. If you are trying to write solid code, when shouldn't one of your goals be writing your code so you can understand and explain why it works?</p>
