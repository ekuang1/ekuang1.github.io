id: dsq-747523419
date: 2007-11-18T19:39:32.0000000-08:00
name: Frans Bouma
avatar: https://disqus.com/api/users/avatars/Frans Bouma.jpg
message: "<p>\"So while I agree with you that Code Coverage is not enough (as I've written before), I'd say proving correctness is not enough because you can't prove the correctness of the spec in meeting customer needs to begin with.\"<br>erm... so what do you deliver to said customer then? An empty zipfile? Or what the customer requested?<br>I'm not debating requirements engineering results here, mind you, I'm arguing if a piece of code is correct or not. A piece of code is correct if the specs it represents in executable form (!) are equal to said executable form. <br>Ok, let's hammer you once more and then I'll leave it. <br>- you've to write a piece of code<br>- you cook up an algorithm A, and you implement A. A is actually subdivided in smaller algo's, A1...An. You all implement them. As you think algorithms are hard to prove correct (did you ever used quicksort? Why did you assume the code worked?), you don't prove A1...An are correct, why bother, right?<br>- you write 10,000 tests, they all succeed. <br>- After a while a customer calls, they have a case where your code fails.<br>- you write the 10,001st unittest with that case. It indeed fails. <br>What do you conclude there:<br>a) A suckes, but your implementation of it is correct<br>b) A is ok, but your implementation of it sucks<br>c) all of the above.<br>?<br>Don't you realize that if you don't know if A is correct, you're DOOMED to patch your code till oblivion ? Because what if your code is actually a) ? Then the poor sods who take over the project from you (or yourself!) are in deep ****, because it's a matter of time before some other customer calls with yet another case. <br>I.o.w.: if you don't know IF your algorithms work (for the algorithm-impaired: that's not 'code'), you can never deliver a program which is correct, as you can put a lot of work in writing the code, but it is highly unlikely that that code is correctly functioning software. Scrap-book programming. <br>Oh and Phil... EVERY programmer out there has deep confidence in his/her own work. So if a programmer comes to me and says \"I'm confident it works\" I don't give a hoot: I'd be confident too if I wrote it, aren't we all? Even if there are thousands of tests to prove the confidence is 'legit'! ;)<br>Like I said: proving correctness is hard sometimes (read: a lot of work). But no-one said it was easy: developing software IS hard (read: a lot of work). <br>I also fail to see what Nasa has to do with it btw. As if your customer isn't important. As if THEY don't pay perhaps hundreds of thousands of dollars to get software their company will RELY on!<br>Think about that for a change: a lot of software has to be reliable, has to work all the time, no edge cases etc. Do you have 'enough confidence' to say that to your customer, based on a set of unittests? Why not take the safe side and be sure?</p>"
