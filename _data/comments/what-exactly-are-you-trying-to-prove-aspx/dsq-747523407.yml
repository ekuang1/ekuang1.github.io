id: dsq-747523407
date: 2007-11-16T23:37:35.0000000-08:00
name: Haacked
avatar: https://github.com/haacked.png?size=120
message: <blockquote>I will write a simple implementation generator that examines the test and derives the implementation from that, covering exactly and only the finite inputs of the test</blockquote><p><br>That is certainly a way to explicitly find the points in a test suite that fail, but hopefully, in the real world, when you're writing code and tests, you don't work against yourself in such a manner. Of course you'd be working on making sure as you write the code that it is correct.<br>Also, this ignores the fact that your inputs to the tests generally represent equivalence classes. For example, when you write a method that performs some calculation on an int. You don't have to pass in every possible int to test the calculation thoroughly. You would pass in a set of values that represent equivalence classes. For example:<br>0 - //often finds divide by 0<br>1<br>int.MinValue //Tests for overflow handling<br>int.MaxValue //Tests for overflow handling<br>7 - //some random int where you know the expected outcome<br>There may be other values you'd test based on the specifics of the calculation.<br>With five or so test cases, depending on the calculation and how well you understand the code to perform that calculation, you as the developer writing that code now have a huge amount of confidence without having to prove the calculation.<br>Again, I'm not saying you shouldn't spend time in design. I'm saying that provably correct code is *not* a developer's main focus. It's being able to respond to the needs of the user and writing as correct code as possible in a reasonable time frame as determined by the requirements.<br>For the Space Shuttle, that probably means provably correct code. For most other apps, provably correct code means you never respond to market shifts. Your app comes out too late.<br>If provably correct code is a developer's main focus, we should all be writing LISP.</p>
