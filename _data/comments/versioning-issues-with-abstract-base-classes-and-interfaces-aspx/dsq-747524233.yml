id: dsq-747524233
date: 2008-02-22T03:49:55.0000000-08:00
name: David Nelson
avatar: https://disqus.com/api/users/avatars/David Nelson.jpg
message: <p>@krzysztof = "Many of our customers don’t want to recompile when they move to a new Framework version. Many would not have a problem with having to recompile. Both groups have valid reasons for their preferences, but we can only serve them all by not requiring recompiling."<br>But you are NOT serving them both! You are serving one group by not forcing them recompile, but you are NOT serving the other by limiting your design around this artificial constraint that the other group shouldn't have to recompile, thereby making the design less evolvable. You are not serving them both; you are choosing to serve one instead of the other. This is something that I have been trying to get across to .NET team members for the last several years, but its like I'm banging my head against a brick wall.<br>@krzysztof = "I participated in many meeting where we considered a breaking change, decided that the risk of brakes in customers’ code is close to nil, made the change, and then had to revert it in Beta because it was after all breaking many apps. This is the nature of a very large frameworks used by millions of applications. If a change breaks just 0.1% of applications, it still breaks 1000 apps and it costs the customers headaches and money to fix them."<br>Yes, it does! So what? Every time the U.S. military plans an operation, the operation includes a concept of acceptable losses, i.e. the maximum number of casualties that can be sustained and still consider the operation a success. The more important the operation, the higher the acceptable losses. If you are saying that when planning a breaking change, acceptable losses of 0.1% of clients is too high, then you will never ship a breaking change! And you are thereby shooting yourself in the foot, and dooming yourself to be the victim of your previous mistakes. This is the road that I think .NET is heading down, and it saddens me greatly that the .NET team is blindly rushing toward the edge of the cliff.<br>By the way, I have watched that entire presentation before, and I completely disagree with the vast majority of it. It is predicated on the assumption that most people are stupid and that we should design for the lowest common denominator (most C# programmers don't understand dynamic casts?!?). It also assumes that backward compatibility is the number one design goal of all library developers, which in a very large percentage of cases is not true (but good luck convincing anyone at Microsoft of that). It SCARES ME that this is the thought process that the .NET framework goes through during its design phase. On the other hand, it explains a lot too.</p>
