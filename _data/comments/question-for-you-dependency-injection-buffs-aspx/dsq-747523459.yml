id: dsq-747523459
date: 2007-11-27T18:01:43.0000000-08:00
name: Magnus M&#229;rtensson
avatar: https://disqus.com/api/users/avatars/Magnus M&#229;rtensson.jpg
message: "<p>Hi!<br>Enterprise Library uses attributes to mark injection points - constructor parameters, property setters and even methods (which are executed after all is done - useful for Init() type methods).<br>If you use the attribute DependencyAttribute you can specify which type you depend upon which is usually an interface and also you can specify a string key. Then you can specify at app startup which policies should govern your creations. You can set a default policy and also specific ones which govern the creation of your dependent objects.<br>For instance you can have this attribute:<br>public class MyController : IController<br>{<br>  MembershipProvider membership;<br>  [InjectionConstructor]<br>  public HomeController([CreateNew]MembershipProvider provider)<br>  {<br>    this.membership = provider;<br>  }<br>}<br>Normally I'd prefer to use an interface so I can - via policy - direct which implementor is injected. The [CreateNew] attribute would instead be [Dependency(CreateType = typeof(IMembershipProvider), Name=\"Home Membership Provider\", NotPresentBehavior = NotPresentBehavior.CreateNew)]. Where IMembershipProvider is the interface implemented in MembershipProvider. This way I can easily dynamically proxy it for test, I can proxy it for Policy Injection (AOP) and I can set policies for which type it maps to:<br>policyList.Set&lt;ITypeMappingPolicy&gt;(new TypeMappingPolicy(typeof(MembershipProvider), valueID), typeof(IMembershipProvider), \"Home Membership Provider\")<br>The policy is returned when I ask the type mapper strategy for the keyType and keyId.<br>Finally ;~) I have also created a config section which adds policies to my system from config.<br>Cheers,<br>/Magnus</p>"
