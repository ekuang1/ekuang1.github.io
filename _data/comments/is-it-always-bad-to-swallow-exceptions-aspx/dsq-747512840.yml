id: dsq-747512840
date: 2005-08-10T04:07:00.0000000-07:00
name: Haacked
avatar: https://github.com/haacked.png?size=120
message: <p>Right, but it isn't a NEVER EVER issue.<br><br><br><br>Suppose that method was used in a tight loop and called very often, but 95% or more of the strings passed to that method are valid numerics. In that case, I would probably leave the method as is.<br><br><br><br>But if only 50% or less were numerics, then I would almost definitely look for another solution.<br><br><br><br>In both cases, I would measure first, then make the optimization, then measure again.<br><br><br><br>The regular expressions for matching integers are fairly easy, but get more complicated if you want to allow commas as the thousand separators. Of course, it's doable, but I hate to roll my own solution to something that is already superbly tested.<br><br><br><br>For example, ever try validating floating point numbers using Regex? It's a bit more challenging than many people realize. Often, you take the naive approach ([-+]?[0-9]*\.?[0-9]*) which ends up being wrong.<br><br><br><br>Also, as I pointed out, what if we were trying to validate something even more complicated? For example, a GUID. You could use a Regex<br><br><br><br>^(\{){0,1}[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}(\}){0,1}$<br><br><br><br>but how readable is that?<br><br><br><br>But I am in total agreement that the code Jayson displayed was faulty in that it blindly caught ALL exceptions, rather than the one exception it was interested in</p>
