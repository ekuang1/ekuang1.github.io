id: dsq-757301911
date: 2013-01-05T16:57:14.0000000-08:00
name: mattmc3
avatar: https://disqus.com/api/users/avatars/mattmc3.jpg
message: <p>One of the first thoughts I had about this was how this would handle optional parameters?  With optional parameters, the situation is reversed where the majority of the time you do want to allow null, and adding verbosity to the syntax for that would not be ideal.</p><p>I really like the idea of using AOP for this.  It's sorely needed.   But, what I've often found is that null checking really isn't the only parameter checking you want to do.  For strings, it's more often checking !String.IsNullOrWhiteSpace().  And when you get into DBC (design-by-contract), you begin to see all the other assumptions that are part of your contract - not just non-nullability.  For my projects, I used a variation of the method described here:  <a href="http://rogeralsing.com/2008/05/10/followup-how-to-validate-a-methods-arguments/" rel="nofollow noopener" title="http://rogeralsing.com/2008/05/10/followup-how-to-validate-a-methods-arguments/">http://rogeralsing.com/2008...</a></p><p>This means that most of my methods start with something like:</p><p>Verify.That(stringParam, "stringParam").IsNotNullOrWhiteSpace();<br>Verify.That(intParam, "intParam")<br>  .IsGreaterThanOrEqualTo(0)<br>  .IsLessThan(100);</p><p>It's worked really well for me.  I even share the fluent API for my unit testing, so instead of "Assert.AreEqual(expected, stringVariable)", I do "Test.That(stringVariable).IsEqualTo(expected)".<br></p>
