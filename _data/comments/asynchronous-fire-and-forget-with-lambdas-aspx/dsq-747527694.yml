id: dsq-747527694
date: 2009-01-09T20:47:18.0000000-08:00
name: Justin Chase
avatar: https://disqus.com/api/users/avatars/Justin Chase.jpg
message: <p>I hate to be a downer but I'm going to have to say this is a bad idea. Honestly, when do you ever want to fire and forget? Your example there is about sending an email message, you really aught to be baking in some mechanism for handling exceptions otherwise this is an equivalent crime to catch(Exception) { }<br>How about:<br><code><br>delegate void AsyncResult&lt;TResult&gt;(TResult result, Exception error);<br>delegate void AsyncResult(Exception error);<br>delegate bool SendEmailDelegate(string to, <br>      string from, <br>      string subject, <br>      string body);<br>public static void Fire(this Delegate d, AsyncResult result, params object[] args)<br>{<br>  ThreadPool.QueueUserWorkItem(() =&gt;<br>  {<br>    Exception error = null;<br>    try<br>    {<br>      dynamicInvokeShim();<br>    }<br>    catch(Exception ex)<br>    {<br>      error = ex;<br>    }<br>    finally<br>    {<br>      result(ex);<br>    }<br>  }, <br>  new TargetInfo(d, args));<br>}<br></code><br>Then have another overload for the AsyncResult&lt;TResult&gt; delegate for methods with expected return results. Call it like this:<br><code><br>// adding "this" to the method makes it an extension method<br>im.Send.Fire(e =&gt; { if(e!=null) Log.Error(e); },<br>             to, from, subject, body);<br></code><br>If you had a nice static log method that was smart enough to check the null for you you could pass that instead of a lambda also.</p>
