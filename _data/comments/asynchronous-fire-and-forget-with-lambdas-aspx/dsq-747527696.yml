id: dsq-747527696
date: 2009-01-10T07:38:04.0000000-08:00
name: JD Conley
avatar: https://disqus.com/api/users/avatars/JD Conley.jpg
message: "<p>&lt;async_propganda&gt;<br>As a scalability/performance junkie (and a subtext user) I'd like to say that if you're sending any quantity of email all of these are bad ideas. :) Using QueueUserWorkItem to create fake asynchronicity in an <a href=\"http://asp.net\" rel=\"nofollow noopener\" title=\"asp.net\">asp.net</a> application is just asking for the \"Server too Busy\" error. What you gain in short term user pleasure you lose in crunch time scalability as you now use up 2x the limited, precious, worker threads. And besides, threads should be processing, not waiting for IO!<br>Waiting around for an email to finish sending (or any IO) in an extra worker threadpool thread takes away from the amount of threads you have available for rendering <a href=\"http://asp.net\" rel=\"nofollow noopener\" title=\"asp.net\">asp.net</a> pages and handling <a href=\"http://ado.net\" rel=\"nofollow noopener\" title=\"ado.net\">ado.net</a> calls. In the scalability sense, if you have to do IO synchronously you might as well just do it in the original <a href=\"http://asp.net\" rel=\"nofollow noopener\" title=\"asp.net\">asp.net</a> thread since QueueUserWorkItem uses the same threadpool as your <a href=\"http://asp.net\" rel=\"nofollow noopener\" title=\"asp.net\">asp.net</a> page processing.<br>The best option here is to use the SendAsync method provided on the System.Net.Mail.SmtpClient class and provide a lambda on the SendCompleted event. This does real asynchronous processing using async IO and IOCP behind the scenes. If you want the page to finish processing rather than go into async rendering mode you can temporarily remove the <a href=\"http://asp.net\" rel=\"nofollow noopener\" title=\"asp.net\">asp.net</a> async context with System.Threading.SynchronizationContext.SetSynchronizationContext(null). I have this little helper class that does it:<br>using System;<br>using System.Threading;<br>namespace Hive7.Core<br>{<br>    public class SynchronizationContextSwitcher : IDisposable<br>    {<br>        private SynchronizationContext _oldContext;<br>        public SynchronizationContextSwitcher() : this(null)<br>        {<br>        }<br>        public SynchronizationContextSwitcher(SynchronizationContext context)<br>        {<br>            _oldContext = SynchronizationContext.Current;<br>            SynchronizationContext.SetSynchronizationContext(context);<br>        }<br>        #region IDisposable Members<br>        public void Dispose()<br>        {<br>            SynchronizationContext.SetSynchronizationContext(_oldContext);<br>            _oldContext = null;<br>        }<br>        #endregion<br>    }<br>}<br>If you can't use the SmtpClient class for some reason and are stuck with the synchronous mail sending option, you should spawn a single long running thread in application_start that polls a thread safe queue, and post to that queue for work, or use some threadpool other than the built-in worker one.<br>&lt;/async_propganda&gt;</p>"
