id: dsq-747510847
date: 2006-05-29T15:07:00.0000000-07:00
name: Sridhara K
avatar: https://disqus.com/api/users/avatars/Sridhara K.jpg
message: "<p>Should I use COALESCE() or ISNULL()? <br> <br> <br> <br>As with many technology questions involving roughly equivalent choices, it depends. There are a variety of minor differences between COALESCE() and ISNULL(): <br>COALESCE() is ANSI standard, so that is an advantage for the purists out there. <br>  <br>Many consider ISNULL()'s readability and common sense naming to be an advantage. While I will agree that it easier to spell and pronounce, I disagree that its naming is intuitive. In other languages such as VB/VBA/VBScript, ISNULL() accepts a single input and returns a single boolean output. <br>  <br>ISNULL() accepts exactly two parameters. If you want to take the first non-NULL among more than two values, you will need to nest your ISNULL() statements. COALESCE(), on the other hand, can take multiple inputs: <br>  <br>SELECT ISNULL(NULL, NULL, 'foo') <br> <br>-- yields: <br>Server: Msg 174, Level 15, State 1, Line 1 <br>The isnull function requires 2 arguments. <br> <br>SELECT COALESCE(NULL, NULL, 'foo') <br> <br>-- yields: <br>---- <br>foo<br> <br> <br>In order to make this work with ISNULL(), you would have to say: <br>  <br>SELECT ISNULL(NULL, ISNULL(NULL, 'foo'))<br> <br>  <br>The result of ISNULL() always takes on the datatype of the first parameter (regardless of whether it is NULL or NOT NULL). COALESCE works more like a CASE expression, which returns a single datatype depending on precendence and accommodating all possible outcomes. For example: <br>  <br>DECLARE @foo VARCHAR(5) <br>SET @foo = NULL <br>SELECT ISNULL(@foo, '123456789') <br> <br>-- yields: <br>-----  <br>12345 <br> <br>SELECT COALESCE(@foo, '123456789') <br> <br>-- yields: <br>---------  <br>123456789<br> <br> <br>This gets more complicated if you start mixing incompatible datatypes, e.g.: <br>  <br>DECLARE @foo VARCHAR(5), @bar INT <br>SET @foo = 'foo' <br>SET @bar = NULL <br> <br>SELECT ISNULL(@foo, @bar) <br>SELECT COALESCE(@foo, @bar) <br> <br>-- yields: <br> <br>-----  <br>foo <br> <br>Server: Msg 245, Level 16, State 1, Line 6 <br>Syntax error converting the varchar value 'foo' to a column of data type int.<br> <br>  <br>A relatively scarce difference is the ability to apply constraints to computed columns that use COALESCE() or ISNULL(). SQL Server views a column created by COALESCE() as nullable, whereas one using ISNULL() is not. So: <br>  <br>CREATE TABLE dbo.Try <br>( <br>    col1 INT, <br>    col2 AS COALESCE(col1, 0)  <br>        PRIMARY KEY <br>) <br>GO <br> <br>-- yields: <br>Server: Msg 8111, Level 16, State 2, Line 1 <br>Cannot define PRIMARY KEY constraint on nullable column in table 'Try'. <br>Server: Msg 1750, Level 16, State 1, Line 1 <br>Could not create constraint. See previous errors.<br> <br> <br>Whereas the following works successfully: <br>  <br>CREATE TABLE dbo.Try <br>( <br>    col1 INT, <br>    col2 AS ISNULL(col1, 0)  <br>        PRIMARY KEY <br>) <br>GO<br> <br>  <br>If you are using COALESCE() and or ISNULL() as a method of allowing optional parameters into your WHERE clause, please see Article #2348 for some useful information (the most common techniques will use a scan, but the article shows methods that will force a more efficient seek). <br>  <br>Finally, COALESCE() can generate a less efficient plan in some cases, for example when it is used against a subquery. Take the following example in Pubs and compare the execution plans: <br>  <br>USE PUBS <br>GO <br> <br>SET SHOWPLAN_TEXT ON <br>GO <br> <br>SELECT COALESCE <br>( <br>    (SELECT a2.au_id <br>        FROM pubs..authors a2 <br>        WHERE a2.au_id = a1.au_id), <br>    '' <br>) <br>FROM authors a1 <br> <br>SELECT ISNULL <br>( <br>    (SELECT a2.au_id <br>        FROM pubs..authors a2 <br>        WHERE a2.au_id = a1.au_id), <br>    '' <br>) <br>FROM authors a1 <br>GO <br> <br>SET SHOWPLAN_TEXT OFF <br>GO<br> <br> <br>Notice the extra work that COALESCE() has to do? This may not be a big deal against this tiny table in Pubs, but in a bigger environment this can bring servers to their knees. And no, this hasn't been made any more efficient in SQL Server 2005, you can reproduce the same kind of plan difference in AdventureWorks: <br>  <br>USE AdventureWorks <br>GO <br> <br>SET SHOWPLAN_TEXT ON <br>GO <br> <br>SELECT COALESCE <br>( <br>    (SELECT MAX(Name) <br>        FROM Sales.Store s2 <br>        WHERE <a href=\"http://s2.name\" rel=\"nofollow noopener\" title=\"s2.name\">s2.name</a> = <a href=\"http://s1.name\" rel=\"nofollow noopener\" title=\"s1.name\">s1.name</a>),  <br>    '' <br>) <br>FROM Sales.Store s1 <br> <br>SELECT ISNULL <br>( <br>    (SELECT MAX(Name) <br>        FROM Sales.Store s2 <br>        WHERE <a href=\"http://s2.name\" rel=\"nofollow noopener\" title=\"s2.name\">s2.name</a> = <a href=\"http://s1.name\" rel=\"nofollow noopener\" title=\"s1.name\">s1.name</a>),  <br>    '' <br>) <br>FROM Sales.Store s1 <br> <br>GO <br>SET SHOWPLAN_TEXT OFF <br>GO<br> <br><br> <br> <br> <br></p>"
