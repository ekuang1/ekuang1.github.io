id: dsq-934195391
date: 2013-06-18T05:50:31.0000000-07:00
name: FennNaten
avatar: https://disqus.com/api/users/avatars/FennNaten.jpg
message: "<p>the lack of null check... I think the wrong assumption I see the most <br>often in code is \"this function which returns an object will never <br>return null\". Especially with linq. And in most of the cases, it really <br>shouldn't. But it does. If I take your example:</p><p>IEnumerable&lt;repository&gt; repositories = GetRepositories();<br>repositories.ToDictionary(r =&gt; r.CloneUrl);</p><p>Here it depends where GetRepositories come from and how much you trust the source.<br>Because I've seen too many people doing stuff like that:</p><p>public IEnumerable GetRepositories(){<br>    try{<br>        //nothing should go wrong here, but we will try catch, just in case<br>        return GetAllRepositoriesWhichCanBeNullToo().Where(x =&gt; SomeStuffWithAPotentialUnseenCrash(x) == true);<br>    }<br>    catch(Exception ex){<br>        //we don't know how to return an empty enumerable<br>        //nevermind, that will never happend anyaway. let's just return null! And no need to write it in assembly doc! <br>        //And don't rethrow any meaningful exception cause we promised crash free code to our client.<br>        return null;<br>    }<br>}</p><p>Another big classic: \"this will never be 0, let's divide\"<br>In<br> the series of nasty ones: the time related. Like \"nobody will ever run <br>that in another timezone, let's use date as part of the key\"</p>"
