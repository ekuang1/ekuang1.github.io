id: dsq-747524268
date: 2008-03-06T01:01:30.0000000-08:00
name: h
avatar: https://disqus.com/api/users/avatars/h.jpg
message: "<p>... the rest of my comment:<br>See it from the point of the developer: I'd rather get told directly when there's an exception than having to understand the intricacies of overriding public properties to say whether a method exists or not; doing so just leaves you with a mess to end with and it's that messy backwards compatibility that imho. has put the JVM/Java where it is right now. Let's call annotations \"@interface\", override using @Override, do c++ templates/generics (which are compile time btw.) using Erasure - so we have to CAST every object back to Object, so we don't break anything! In their docs they say: \"The main advantage of this approach is that it provides total interoperability between generic code and legacy code that uses non-parameterized types\" - well that's great, but never mind about the useless performance of all that auto-boxing compared to real generics, not to mention what's impossible, like instantiating generic type variables.<br>Looking at how the programs execute, you're likely to have some biggish class which may be sealed or simply doesn't expose that many overridable methods, which resolves for, an invokes your interfaces - you'd have to have this control somehow... If you in this class do extensive invariant checking and inform the programmer when he has violated the invariants, then your argument about the invariants kind of fall. You could even wrap it in a proxy like stated above from here...<br>Which also makes any argument that Ayende hasn't worked on a project the size of the .net framework kind of void, since he's in both NHibernate and MonoRail.<br>So to re-iterate, pros of interfaces:<br>- You can vary the implementation and do composition which you wouldn't be able with ABCs since there's only is-a semantics on subclasses.<br>- From implementor's view: no strange and hidden state changes which is the peril of OOP.<br>- Invariants CAN be checked by framework by proxying.<br>- Greater degree of decoupling in the system. Less magic.<br>- Interfaces inheriting interfaces solves problem with versioning to some extent, or you could version a new MS MVC 3 years from now as different, like GridView/DataGrid had done to them...<br>Cons of interfaces:<br>- \"Too much freedom\"?<br>- \"More breakage iff breakage occurrs\"?<br>- Require other less direct ways of checking invariants<br>For ABCs: <br>- You can add side-effects as you like. (yey.... or???)<br>- You always have assembly redirection! (but hey, we're not breaking anything, just making them change code before it works!)<br>- Invariant checking is very easy<br>From the other blog:<br>\"Typically we used interfaces for all behavioral types, and classes for data objects. The reason is that behavior needs to be mocked, whereas data is just data.\"<br>Furthermore, I figured that I could ask whether you/MS couldn't possibly make a step which isn't very common from big companies and perhaps even send your test-suite bundled with MVC, so that anyone wishing to implement these things can understand how they interact and run your tests on their own implementations? It would be really cool if you could :)<br>It comes around to the question about how good your developers are; if they are good, presumably they are able to create implementations of your interfaces.<br>If you wanted to add functionality without breaking interfaces, maybe even this could work to some extent:<br>interface IView {} // shipping<br>interface IWebForm : IView, IController, IModel {} // next version (hope not)<br>in your MSMVCHttpHandlerFactory:<br>someMethod() {<br>var view = services&lt;IView&gt;();<br>if (view is IWebForm)<br>launchHugeOverheadWithView(view as IWebForm); // is garantuees not null<br>else<br>renderer.RenderView(view);<br>}<br>Or something :)</p>"
