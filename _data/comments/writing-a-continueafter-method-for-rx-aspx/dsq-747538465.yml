id: dsq-747538465
date: 2012-10-09T00:47:44.0000000-07:00
name: Jerome Laban
avatar: https://disqus.com/api/users/avatars/Jerome Laban.jpg
message: "<p>The fact that you need to chain two methods like this indicates that you have a state somewhere, and that you're not using the output of the first observable to feed the second. You should probably need to watch out for concurrent subscriptions that may corrupt your state.<br>If you need to mimic the single-value return of a method, you could probably be using this :<br>public static IObservable&lt;string[]&gt; Result()<br>{<br>    Extract()<br>       .ToArray()<br>       .Select(stuff =&gt; GetStuff(stuff).ToArray());<br>}<br>You could still do a SelectMany instead of Select and ToArray, if you really need to have your results provided as a stream instead of a single result.<br>But if you really can't do it any other way, I suggest you to use the Observable.IgnoreElements() follows by a Select(Unit.Default), instead of using Agggregate, which executes a lambda unnecessarily in this case.<br>@Caleb: This gist is ignoring exceptions from the source observable. The couple of Materialize/Where is not going to forward the OnError notification downstream, which can be hiding some pretty nasty bugs. You should probably use Notification.CreateOnNext&lt;&gt;() and Notification.CreateOnError&lt;&gt;() followed by Dematerialize, instead of projecting to the result type with a simple Observable.Select.</p>"
