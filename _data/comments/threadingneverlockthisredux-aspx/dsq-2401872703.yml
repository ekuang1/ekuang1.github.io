id: dsq-2401872703
date: 2015-12-09T11:32:43.0000000-08:00
name: Ada Lovelace
avatar: https://disqus.com/api/users/avatars/disqus_FaYU8QtA8U.jpg
message: <p>I have had this argument with coworkers and on stack overflow many times.  I therefore dedicated an article in my own blog to state why lock(this) is totally fine and appropriate among other things that they tell you not to do.</p><p>There's a huge, huge flaw in your code there.  Why on earth are you holding lock(this) while waiting on a thread.join() that is also wanting a lock on that object?  THAT IMO is the bad practice.  The code is basically doing exactly what you told it to do, you created a thread, passed it an object, and blocked it from actually being able to do work.  This is the same thing that would happen if in C++ you passed a critical section object to another thread that you forgot to unlock.</p><p>Deadlocks happen if you're not careful, but so far no soul has actually demonstrated to me a situation where lock(this) is actually the real source of any problem.  And my blog demonstrates reasons and scenarios where calling lock(this) is actually far less likely to introduce deadlocks than locking internal objects.</p><p>So far no one has shown me a substantive argument against using lock(this).  Were you really expecting the worker thread to operate properly even though you held a lock on it throughout its entire execution time?  This argument seems more about design semantics and IMO, when the Microsoft documentation says that you "shouldn't do something", it really should be based on fact, not philosophy.</p><p>Anyway, you can argue that calling lock(this) was "bad form" in your example, or you could argue that holding a lock on data that another thread needs to do its work is bad form.  Regardless, shared data needs to be locked sometimes and it really doesn't matter how it gets locked, as long as you know what you're doing and plan accordingly.</p>
