id: dsq-747518813
date: 2007-03-11T21:58:33.0000000-07:00
name: zakwilson
avatar: https://disqus.com/api/users/avatars/zakwilson.jpg
message: <p>Tony, mapping a function over a list isn't recursion[0], though it is a good way to solve this problem. I would <strong>not</strong> use recursion to solve fizzbuzz; iterative and functional solutions are shorter, clearer and less error-prone. Here are solutions in Common Lisp:<br><code><br>(defun fizzbuzz-iterative ()<br>  (loop for x from 1 to 100 do<br>(cond ((and (= (rem x 3) 0)<br>    (= (rem x 5) 0))<br>       (print "FizzBuzz"))<br>      ((= (rem x 3) 0)<br>       (print "Fizz"))<br>      ((= (rem x 5) 0)<br>       (print "Buzz"))<br>      ('t (print x)))))<br></code><br><code><br>(defun fizzbuzz-recursive (&amp;optional (x 1))<br>  (cond ((&gt; x 100)<br> (return-from fizzbuzz-recursive 'nil))<br>((and (= (rem x 3) 0)<br>      (= (rem x 5) 0))<br> (print "FizzBuzz"))<br>((= (rem x 3) 0)<br> (print "Fizz"))<br>((= (rem x 5) 0)<br> (print "Buzz"))<br>('t (print x)))<br>  (fizzbuzz (1+ x)))<br></code><br>and a fizzbuzz function that can be mapped across any list of integers:<br><code><br>(defun f (x)<br>  (cond ((and (= (rem x 3) 0)<br>      (= (rem x 5) 0))<br> (print "FizzBuzz"))<br>((= (rem x 3) 0)<br> (print "Fizz"))<br>((= (rem x 5) 0)<br> (print "Buzz"))<br>('t (print x))))<br></code><br>[0] A given language might implement map recursively or iteratively - this should be invisible to the user.</p>
