id: dsq-747524299
date: 2008-03-04T15:34:46.0000000-08:00
name: Eamon Nerbonne
avatar: https://disqus.com/api/users/avatars/Eamon Nerbonne.jpg
message: <p>Well, if by HTTP intrinsics you mean ASP.NET basics such as HttpContext, I've run into issues with those being classes, and not a multitude of small interfaces.<br>A caching helper was using a number of HttpContext features.  Turns out, the caching helper might be useful elsewhere, but is written to access HttpContext.  If I could have merely reimplemented the appropriate interface (say, the caching) I could have wrapped the original instance without problem or code-change, and referred it to the non-web back-end in the non-web case.  Now, it means re-inspecting the code for it (which fortunately is available), and refactoring it to use a home-grown interface.  That's a really unfortunate solution, however, since it means there will never be any sort of modularity here.  This particular home-grown interface is only used in one project, and there are no drop in replacements, nor other consumers.<br>This is probably not the best example, but merely one I happened to run into recently.<br>For that matter, let's say I have a nice IHttpHandler somewhere, which happens to have been written for the web, but is useful elsewhere - I can't call that thing without a reference to an HttpContext, and HttpContext is a class so I can't safely reimplement useful features.  Furthermore, it's huge; rather than being a composisiton of mostly independant interfaces, it's one big object with potentially a lot of black-box "magic" happening inside - who knows?  Certainly, it's unfortunate.<br>Basically, the [i]core[/i] programming tenet of encapsulation is violated by using ABC's.  They fail as an encapsulation mechanism since you cannot replace them where needed.  The very fact that they have a real namespaced name, with implementation bits lying around, means that [i]replacing[/i] that implementation is impossible - at best you can subclass; but without knowing the implementation details, it's a random bunch of guess work - who knows what side effects the constructor has?  How easy is it to work around the explicit interface implementation you can't override?  What happens if some functions can't be overridden by (mis)design?  It's much, much harder to make software in well-compartmentalized bits if the core is so inflexible.</p>
