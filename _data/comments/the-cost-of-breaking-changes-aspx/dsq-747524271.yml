id: dsq-747524271
date: 2008-03-03T18:11:15.0000000-08:00
name: Eamon Nerbonne
avatar: https://disqus.com/api/users/avatars/Eamon Nerbonne.jpg
message: "<p>Of course, using extension methods can provide a work-around in many cases.  <br>I find that the lack of multiple inheritance makes ABC's terribly annoying to work with.  Helper classes with syntactic aids such as extension methods can help maintain binary compatibility in those cases where the new interface is merely an extension of the old.<br>If you're only providing new utility functions which don't affect the core capabilities, why not use an interface [i]and[/i] an ABC/utility wrapper?  If you are introducing new, important changes which can't trivially be introduced, then the problem lies not with the versioning differences between interfaces and abstract base classes, but in the new functionality, and ABC's won't help.<br>In my experience, dealing with ABC's is much more frustrating than dealing with interfaces for three reasons:  Firstly, precisely because they indeed can include hidden functionality designs using them are less transparent and more difficult to understand and debug, and worse yet, indeed they can add this functionality in non-obvious places after the fact.  Secondly, using an ABC often precludes using an appropriate base class since you're forced to use the one provided.  Also, you can use only one ABC, which means that orthogonal concepts can't be combined despite there being no technical reason for that limitation.  A combined interface+ABC approach would at least allow for the ugly but functional wrapper-object approach which simply forwards all methods of interface A to the appropriate instance and all methods of interface B to the appropriate interface.  Thirdly, and not irrelevantly, ABC's often lead to badly designed and bloated API's precisely because it's so easy to increase their size.  This may not be a causal relationship, but it's uncanny how much cleaner the core .NET frameworks interfaces are than the core .NET frameworks classes.<br>Let's also not that it is possible to use generics trick to make interfaces which can be extended with new functionality without breaking changes, but really, all this shows is that the C# and the .NET framework really fail at providing mix-in like functionality.  This isn't so much a difference between dynamic and static languages (although clearly it's a more obvious feature in dynamic languages), as a slightly more complex feature.  A class with a mix-in isn't really much more than a class with a generic parameter T, and one read-only field of that type T which is initialized appropriately.<br>My vote is against ABC's, in all cases excepting only those where the object has an inherent coupling to the platform (such as where alternate implementations might pose a security risk, like the array or list types do).<br></p>"
