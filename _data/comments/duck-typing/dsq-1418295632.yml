id: dsq-1418295632
date: 2014-06-03T14:44:01.0000000-07:00
name: mike
avatar: https://disqus.com/api/users/avatars/mike.jpg
message: <p>If you are explicitly checking types in a duck type language you are completely misunderstanding the point.</p><p>Checking types in a duck typed language is a newbie error.<br>In Ruby:</p><p>class PetOwner<br>  def take_care_of pet<br>    pet.walk<br>  end<br>end</p><p>That is all that is needed. If the pet can't walk, as you noted method missing can rescue it, but the design is wrong. Removing that method and putting it in a module and than including it if the Owner has a pet that requires to be walked.</p><p>module WalkablePet<br>  def take_pet_for_walk<br>    @walkable_pet.walk<br>  end<br>end</p><p>module CarMaintianable<br>  def take_care_of_car<br>   @car.maintain<br>  end<br>end</p><p>class Owner<br>def initialize walkable_pet=nil, car=nil<br>  @walkable_pet=walkable_pet<br>  @car=car<br>  finalize<br>end<br>private<br>def finalize<br>  extend WalkablePet unless @pet.nil?<br>  extend CarMaintianable unless @car.nil?<br>end<br>end</p><p>owner = <a href="http://Owner.new" rel="nofollow noopener" title="Owner.new">Owner.new</a> <a href="http://WalkingPet.new" rel="nofollow noopener" title="WalkingPet.new">WalkingPet.new</a>,<a href="http://Car.new" rel="nofollow noopener" title="Car.new">Car.new</a><br>owner.take_pet_for_walk<br>owner.take_care_of_car</p><p>The only thing missing is to add method_missing to print out if the owner doesn't have a car or pet if one or both or those mixins don't exist for that object and of course adding setters to allow for the owner to get a pet or car.</p><p>Duck typed and maintainable within the contrived example. There are much cleaner duck typed solutions that can more easily and cleanly handle adding new things that an Owner can own.</p><p>Duck typing is an informal term but, depending on the language can have a precise meaning.    Ruby is a good example of this. Ruby is dynamically and strongly typed. A Ruby object can never be coerced to a different type, including up or down the inheritance chain. In other words, objects can not be cast to any type. You can’t coerce a Fixnum to be one of its parents(like Integer), and you can’t coerce it to be a float. However, what an object can respond to can be added at any time.</p><p>In Ruby, the actual type doesn’t matter, it is what can it do that matters. If an object responds to a method, it gets called, otherwise, method_missing gets invoked, and if that method is not overridden to deal with it an exception is raised.</p><p> A good Duck typed language erases the need for a lot of standard patterns you see in the more rigid languages. The book Eloquent Ruby has an outstanding chapter that covers what Duck typing is, what it buys you, and what pitfalls to look out for. If you are a C# or Java fan, it might piss you off because it shows how duck typing makes dozens of lines of code, boilerplate or not, disappear.</p><p>You two are over complicating something very simple. Your usage of C# is probably where you and the OP went wrong.  If you want to learn about Duck Typing, use an actual language that has first class support for it. If you are checking types in Ruby, you are writing verbose, pointless code. If you see method calls to is_a? or class, 99.9% of the time, the author doesn’t understand Ruby in the slightest and is likely trying to make it work like Java.</p><p>Just like if you really want to learn what object oriented programming is you don’t reach for C++, Java, Python, PHP or C# because they all miss the point, to varying degrees(but they are still all wrong). You use Smalltalk or Ruby because they actually grok and implement OO correctly.</p>
