id: dsq-1107641825
date: 2013-11-03T13:51:26.0000000-08:00
name: Kendall Bennett
avatar: https://disqus.com/api/users/avatars/kendallbennett.jpg
message: <p>Please note that this method will work but ONLY for dependencies that are globally scoped. You cannot inject anything that might be HttpRequest scoped or you will end up with some really odd problems. One of which is those items will hang around and never get disposed of, and you WILL end up with threads stomping on them eventually causing you thread issues. This is discussed in more detail here:</p><p><a href="http://www.sapiensworks.com/blog/post/2013/03/18/Http-Module-Dependecy-Injection-with-Autofac-Gotcha.aspx" rel="nofollow noopener" title="http://www.sapiensworks.com/blog/post/2013/03/18/Http-Module-Dependecy-Injection-with-Autofac-Gotcha.aspx">http://www.sapiensworks.com...</a></p><p>However that approach is really no different to using a service locator pattern either, because the injected dependencies are just injected service locator callbacks. I think the correct solution is to update HttpModuleMagic such that it creates a new instance of service module that performs JUST the services, which is DI injected, at the time when the request first starts up. And then pass the calls from the real module to the request scoped module. Still a hack, but cleaner in that you CAN use request scoped items in the module.</p><p>I would bet most people (myself included) who want this ARE trying to inject items that need to be request scoped (like data access layers for authentication etc), and if they do it this way they will end up with really nasty, hard to track down load induced bugs. Been there, done that. I went back to a service locator pattern for now until I can come up with something better.</p>
