id: dsq-747517681
date: 2006-11-19T02:24:42.0000000-08:00
name: Rick Strahl
avatar: https://disqus.com/api/users/avatars/Rick Strahl.jpg
message: <p>Phil, I don't if 'dynamic query engine' is the right word. I call this layer a Data Access Layer, but I think we're defining this differently &lt;s&gt;... if you look at .Text (and I suppose SubText still uses that base engine, right?) what you have is combined data and business layer. The 'DAL' handles both business logic and data access (hardcoded against Sql Server in one place.<br>In a more tiered architecture you split out the data access into a separate layer, where the data access is basically generic. It's essentially an abstraction layer around SqlClient, OleDbClient, OracleClient etc. which provides additional functionality on top of the base data providers provided by .NET although it looks similar. For example, in my framework there are methods like Execute() (retrieves a DataSet), ExecuteTable(), ExecuteReader(), ExecuteNonQuery() etc. with many overloads that handle various combinations of SQL string/Commands, variable parameters etc more easily than writing raw ADO.NET code. IOW, in my business layer I almost never touch ADO.NET objects directly (except when the results come back like a datatable or reader... It's one more level of abstraction. In .NET 1.1 this was a crucial requirement because .NET lacked a database factory but that's been fixed in 2.0. However, the data layer still provides much value because it's much easier to create query code than with ADO.NET native code. The business object layer ontop of that then provides additional abstraction for many Crud operations, like loading a DataRow or Entity etc.<br>Now your point about database abstraction and differences in engines is a valid one. Obviously if you're using stored procs and another provider doesn't supporting it is a problem, but you neeed to work around that with bracketing. The point though is that this would mostly happen in one place in your business object that talkes to the DAL. There's only one place where the change happens and hopefully there won't be many places where bracketing is required - specifically CRUD operations should be handled in such a way that there are no changes between backends.<br>There are many different ways to build this sort of thing from entity frameworks, to homegrown like mine where DAL and busniess framework interact which each other heavily. What I've built for my self works very well and is super easy to use and maintain and I call it an enitity hybrid implementation (uses a mixture of entity and ADO.NET objects) which seems to me the best tradeoff in performance and usability.<br><br></p>
