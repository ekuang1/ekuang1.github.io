id: dsq-747521977
date: 2007-12-14T04:08:17.0000000-08:00
name: David
avatar: https://disqus.com/api/users/avatars/David.jpg
message: <p>"...no due diligence..." was perhaps a misstatement. What I was trying to say was that duck typing moves the responsibility for the due diligence from the class designer (who under a strict typing system is forced to declare whether a type is compatible with a particular interface) to the class consumer, who is much less likely to fully understand all of the ramifications and unintended consequences of a particular implementation, since they don't have access to its internals. Documentation will only take you so far.<br>It also seems to me that duck typing removes the concept of black box implementation. For example:<br>interface IBar { void Bar1(); }<br>void Foo(IBar a) { a.Bar1(); }<br>In the static type system, you have to pass an instance of type IBar to method Foo. With duck typing, you have to pass an instance which has a Bar1 method. Now, when you're writing your duck-typed application, you are aware of the Bar1 requirement, and you test for it, and make sure that everything works correctly.<br>Now in a future version of the My.Bar library, the IBar interface changes:<br>interface IBar { void Bar1(); void Bar2(); }<br>void Foo(IBar a) { a.Bar1(); a.Bar2(); }<br>Yes, its a breaking change; guess what, they do happen! Now, in a static type system, the Bar which implements IBar and that I was passing to Foo will have to be updated to include a Bar2 method, and in the process I as the designer of the Bar class will make sure that it still meets the requirements of the IBar interface.<br>But in a duck typed system, there is no opportunity to do this kind of verification. Foo has added a requirement that a should include a Bar2 method; if it already does, it will be called, regardless of whether or not it is actually appropriate.<br>This goes back to my original point; duck typing relies completely on member signatures for binding, but they don't tell the whole story. Frankly, this to me is precisely why static typing exists in the first place, and I am at a loss to explain why some people think that using a system which invites unseen breaking changes is a good thing.</p>
