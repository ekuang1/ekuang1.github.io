id: dsq-747521973
date: 2007-12-13T21:31:03.0000000-08:00
name: David
avatar: https://disqus.com/api/users/avatars/David.jpg
message: <p>@Haacked<br>Once again you have missed the point :)<br>Declaritive interface implementation has nothing to do with helping the implementer. You're right; you are responsible for implementing the stated requirements, regardless of the syntax involved. Declaritive interface implementation is about helping the consumer. The point is, you do your due diligence, you design and test your class, and when you are done, you declare that your class is compatible with an interface by declaritively implementing it. Then when I say that method Foo needs an instance of a type which implements IBar, and you have declared that your Bar class implements IBar, a consumer can have confidence that your class will meet the needs of the Foo method (depending on his degree of trust in your implementation).<br>On the other hand, when you start using duck typing, all bets are off. There is no due diligence, there is no declarative implementation, and there is no way for a consumer to know whether a particular method or set of methods correctly fulfills a given set of requirements. All you have is a set of member signatures, which tell you absolutely nothing. Even with good documentation (which is rare), the consumer probably will not have enough information to know whether your type will do the job, because you as the class designer have not had the opportunity to compare the requirements of the interface to your implementation.<br>Again, the biggest problem with requiring this kind of strict typing is that there are many cases when a particular class COULD implement a particular interface, it just doesn't; then you have to get into adapter classes, which require more coding and testing and raise their own design issues. But that doesn't mean that duck typing is the answer.</p>
