id: dsq-747521971
date: 2007-12-13T02:12:55.0000000-08:00
name: Haacked
avatar: https://github.com/haacked.png?size=120
message: <p>With all due respect, I don't think I missed his point. As you point out, there's no way to specify the expected behavior of an interface. Perhaps with new language features such as Spec#, you can specify a contract for the interface and get tighter control over how implementers really implement that interface.<br>But the fact of the matter is, when you expose an interface, you have certain semantics you expect. For example:<br><code><br>public interface Foo<br>{<br> void Add(string id, string value);<br> object Get(string id);<br>}<br></code><br><br>With that interface, you'd expect after calling Add, that a subsequent call to get with the same id returns the object I added in Add.<br>However, it is still incumbent on me, as the implementer of that interface to provide behavior that matches that expectation. The only way I can do that is to test my implementation with your code. I may implement it in an exotic manner.<br>Now whether I implement it with a new class, or whether I implement it by using duck typing with an existing class, it's really none of your business as the one writing the interface.<br>As long as I meet your contract, it doesn't matter. So either way, it's still incumbent on me to make sure I'm implementing the interface in the correct manner.<br>Let's look at the inverse. Suppose that interface is supposed to build a composite structure. So in practice, you call Add multiple times. When the structure is complete, only then does Get return something. Now my implementation of your interface is incorrect.<br>Moral of the story:<br>1. Interfaces don't define enough contract.<br>2. You're on your own as an implementer of the interface, no matter how you implement it.<br>3. You better test your assumptions (ie test your implementation of the interface in the context it was meant to be used).</p>
