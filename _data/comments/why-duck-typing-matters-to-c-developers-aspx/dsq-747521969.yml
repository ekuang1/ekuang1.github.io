id: dsq-747521969
date: 2007-12-13T00:49:22.0000000-08:00
name: David
avatar: https://disqus.com/api/users/avatars/David.jpg
message: <p>@Haacked<br>You completely missed Damien's point. When a class declaratively implements an interface, it is declaring that it not only that it implements members with the same signatures, but that those members correspond to the behavior set forth by the interface. These behaviors cannot be enforced by the compiler of course, but they are an understood prerequisite of interface programming. By designing a method that takes an ICollection&lt;T&gt; as an argument, I am not only requiring the argument to have Add and Remove methods, but also that those methods behave in a particular way. If you try to pass in a type that has Add and Remove methods, but doesn't implement ICollection&lt;T&gt; (i.e. a type that has not declared that its behavior is compatible with ICollection&lt;T&gt;), the compiler will stop you.<br>When you use duck typing, you throw all that away. Any class can be used in any context as long as the signatures match; but signatures are only part of the equation. Of course, strict typing creates its own problems (what happens when an existing class doesn't explicitly implement an interface, perhaps from another assembly, even though its behavior is compatible?). But duck typing, especially in the form in which it is currently being forced upon developers in C# 3.0, is not the answer; it merely trades one set of problems for another.</p>
