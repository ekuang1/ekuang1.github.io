id: dsq-3463063564
date: 2017-08-11T10:00:08.0000000-07:00
name: Tim
avatar: https://disqus.com/api/users/avatars/disqus_339bWatj6G.jpg
message: <p>I've done something very similar with a recent project.  One difference is that I wrapped the checks in a reusable library and then execute them as unit tests in each solution on every build -- failing the build if they fail.  (I pass in a reference to the main site assembly to do the checks.)  This helps as the analysis is not in deployable code.</p><p>The unit tests looks for some form of authorize on all actions (ignoring actions when AllowAnonymous or ChildActionOnly attributes are used -- the former helping out in being declarative in intent for a login page not needing authentication.)  Additionally, like in your example, the tests look for non-get actions and ensure that the anti-forgery validation attribute is present. Another situation we also check for (since we are using OAuth) is to ensure that no non-get action is decorated to be invoked by a user with 'read-only' access -- This is a little more solution specific...</p><p>To make the tests repeatable in a build environment, the tests allow a pre-configured list (in the unit test definition) of ignore patterns to be passed in to the library methods so that if there is a reason to break convention, the method signature can be ignored on a case-by-case basis allowing the tests to pass once reviewed.</p><p>One might argue that these 'unit tests' are more of code convention policies and/or code analysis rules, but we've found that forcing them on the build server ensures lazy developers are held accountable...</p>
