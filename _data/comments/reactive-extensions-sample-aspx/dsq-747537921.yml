id: dsq-747537921
date: 2012-04-09T14:22:58.0000000-07:00
name: Dave
avatar: https://disqus.com/api/users/avatars/Dave.jpg
message: "<p>Your post does a great job of highlighting one of the primary features of Rx: coordination of events.  I believe it's very important for devs that are new to Rx to understand the benefits of LINQ compared to imperative-style code.<br>Though it's equally as important to understand that Rx goes a step farther by introducing the concepts of asynchrony into LINQ.  Your query can be improved by considering asynchrony.  First, realize that sequences can (and should) contain data.  The events that indicate when a window resizes or moves are raised on the UI thread, so perhaps it would be best to change the semantics of the query right away; i.e., project the events via the Select operator into a sequence of window positions: IObservable&lt;Rect&gt;.  That way you can keep Throttle entirely asynchronous, without passing in the DispatcherScheduler.  Think about it this way:  Why force the remainder of the query back onto the UI thread simply to grab a Rect?  Furthermore, if the remainder of the query (e.g., SavePlacement) is going to do file I/O, then you wouldn't want it to block the UI thread.  So of course you make it save asynchronously.  But now you'll probably want to bring it back into the world of the monad before doing anything else asynchronous, because that's where async coordination is thread-safe; e.g., to prevent older data from overwriting newer data (though I understand that the interval for throttle is quite large to avoid this race condition, but the reason is not obvious from the semantics of the query, which is bad for future maintenance.)<br>This way introduces concurrency by executing SavePlacement on a pooled thread, but it ensures that no older data will ever overwrite previous data.<br>var sizeChanges = <br>from e in Observable.FromEventPattern&lt;SizeChangedEventHandler, SizeChangedEventArgs&gt;(h =&gt; SizeChanged += h, h =&gt; SizeChanged -= h)<br>select new Rect(Left, Top, Width, Height);<br>var locationChanges = <br>from e in Observable.FromEventPattern&lt;EventHandler, EventArgs&gt;(h =&gt; LocationChanged += h, h =&gt; LocationChanged -= h)<br>select new Rect(Left, Top, Width, Height);<br>sizeChanges.Merge(locationChanges)<br>.Throttle(TimeSpan.FromMilliseconds(250))<br>.Subscribe(SavePlacement);<br>...<br>void SavePlacement(Rect windowPlacement)  // not an async method<br>Alternatively, if you don't like the \"extra\" concurrency that Throttle introduces, then you should include the file I/O in the query itself: <br>sizeChanges.Merge(locationChanges)<br>.Throttle(TimeSpan.FromMilliseconds(250), DispatcherScheduler.Instance)<br>.Select(rect =&gt; Observable.FromAsync(() =&gt; SavePlacement(rect)));  // Rx 2.0 Beta<br>.Concat()// ensures that older data doesn't overwrite newer data<br>.Subscribe();// execute the query for its side-effects<br>...<br>async Task SavePlacement(Rect windowPlacement)  // C# 5</p>"
